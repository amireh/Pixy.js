define(function(require) {
  var _ = require('underscore');
  var Logger = require('./mixins/logger');
  var Events = require('./mixins/events');
  var Dispatcher = require('./core/dispatcher');
  var Registry = require('./core/registry');
  var extendPrototype = require('./util/extend');
  var wrapArray = require('./util/wrap_array');
  var RSVP = require('rsvp');
  var InflectionJS = require('inflection');

  var extend = _.extend;
  var CHANGE_EVENT = 'change';
  var ACTION_SUCCESS_EVENT = 'actionDone';
  var ACTION_ERROR_EVENT = 'actionError';
  var RESPONSE_JSON = 'responseJSON';

  function actionSuccessEventName(action) {
    if (!action) {
      return undefined;
    }

    return [ ACTION_SUCCESS_EVENT, action ].join(':');
  }

  function actionErrorEventName(action) {
    if (!action) {
      return undefined;
    }

    return [ ACTION_ERROR_EVENT, action ].join(':');
  }

  function onPayload(action) {
    var handler = this.actions[action.id];

    return new RSVP.Promise(function(resolve, reject) {
      var onChange = this._actionEmitter(action, resolve);
      var onError = this._errorPropagator(action, reject);

      if (handler) {
        try {
          handler.call(this, action.payload, onChange, onError);
        } catch(error) {
          onError(error);
        }
      }
      else {
        this.onAction(action.type, action.payload, onChange, onError);
        resolve();
      }

    }.bind(this));
  }

  function bind(store, event, callback, context) {
    if (context && context.listenTo) {
      context.listenTo(store, event, callback);
    } else {
      store.on(event, callback, context);
    }
  }

  function unbind(store, event, callback, context) {
    if (context && context.listenTo) {
      context.stopListening(store, event, callback);
    } else {
      store.off(event, callback, context);
    }
  }

  /**
   * @class Pixy.Store
   *
   * An implementation of the Flux Data Store objects.
   */
  var Store = function(name, schema) {
    extend(this, schema, {
      name: name
    });

    this._key = name.underscore().replace(/_store$/, '').camelize(true);

    Dispatcher.register(onPayload.bind(this));
    Registry.checkObject(this);

    if (this.initialize) {
      this.initialize();
    }
  };

  extend(Store.prototype, Logger, Events, {
    name: 'GenericStore',
    actions: {},

    /**
     * Notify all subscribed listeners that the store's data has been updated.
     */
    emitChange: function(attr, value) {
      this.debug('Broadcasting change.');

      if (attr) {
        this.trigger('change:' + attr, value);
      }

      this.trigger(CHANGE_EVENT);
    },

    emitActionSuccess: function(action, actionIndex) {
      this.debug('Broadcasting action success:', action);
      this.trigger(actionSuccessEventName(action), actionIndex, action);
      this.trigger(ACTION_SUCCESS_EVENT, action, actionIndex);
    },

    /**
     * Notify subscribers that an error was raised performing a specific store
     * action.
     *
     * @param  {String} action
     *         Name of the action in which the error was raisde.
     *
     * @param  {Integer} actionIndex
     *         The action index generated by the dispatcher.
     *
     * @param  {Object} error
     *         The error.
     */
    emitActionError: function(action, actionIndex, error) {
      this.warn('Broadcasting action error:', action, '#', actionIndex);
      this.warn(error, (error && error.stack ? error.stack : undefined));

      this.trigger(actionErrorEventName(action), actionIndex, error);
      this.trigger(ACTION_ERROR_EVENT, action, actionIndex, error);
    },

    /**
     * @param {function} callback
     */
    addChangeListener: function(callback, thisArg) {
      bind(this, CHANGE_EVENT, callback, thisArg);
    },

    /**
     * @param {function} callback
     */
    removeChangeListener: function(callback, thisArg) {
      unbind(this, CHANGE_EVENT, callback, thisArg);
    },

    /**
     * Register an action success handler for a specific store action.
     *
     * @param {String}   action
     * @param {Function} callback
     */
    addActionSuccessListener: function(actions, callback, thisArg) {
      var that = this;
      wrapArray(actions).forEach(function(action) {
        bind(that, actionSuccessEventName(action), callback, thisArg);
      });
    },

    removeActionSuccessListener: function(action, callback, thisArg) {
      unbind(this, actionSuccessEventName(action), callback, thisArg);
    },

    /**
     * Register an error handler for a specific store action.
     *
     * @param {String}   action
     *        A specific action to listen to for errors. Errors caused in other
     *        actions will not be dispatched to your callback.
     *
     * @param {Function} callback
     */
    addActionErrorListener: function(action, callback, thisArg) {
      bind(this, actionErrorEventName(action), callback, thisArg);
    },

    removeActionErrorListener: function(action, callback, thisArg) {
      unbind(this, actionErrorEventName(action), callback, thisArg);
    },

    /**
     * Register an error handler to be called on any store action error.
     *
     * @param {Function} callback
     */
    addErrorListener: function(callback, thisArg) {
      bind(this, ACTION_ERROR_EVENT, callback, thisArg);
    },

    removeErrorListener: function(callback, thisArg) {
      unbind(this, ACTION_ERROR_EVENT, callback, thisArg);
    },

    /**
     * @protected
     *
     * Dispatcher callback for this store. This is where you receive the payload
     * from the dispatcher and get a chance to handle the action if you know how
     * to.
     *
     * @param  {String} action
     *         Unique action id. Usually identified by a constant.
     *
     * @param  {Object} payload
     *         Action-specific parameters.
     *
     * @param {Function} onError
     *        Call this if your handler was unable to process the action.
     *        See #_errorPropagator for more information.
     */
    onAction: function(/*action, payload, onError*/) {
    },

    /**
     * @private
     *
     * @note This is automatically generated for you and passed as an argument
     *       to #onAction.
     *
     * @param {Object} action
     *        The action specification.
     *
     * @param {String} action.type (required)
     *        Unique name of the action.
     *
     * @param {Integer} action.index (required)
     *        Action instance identifier as generated by the dispatcher.
     *
     * @return {Function}
     *         An "onError" function to pass to your action handler so that it
     *         calls it if it couldn't process the action.
     *
     *         The callback receives a single argument which should be an object
     *         describing your error.
     *
     *         The callback will emit the appropate action error.
     */
    _errorPropagator: function(action, reject) {
      return function(error) {
        if (error && _.isObject(error) && RESPONSE_JSON in error) {
          error = error.responseJSON;
        }

        this.emitActionError(action.type, action.index, error);
        reject(error);
      }.bind(this);
    },

    _actionEmitter: function(action, resolve) {
      return function(attr, value) {
        this.emitActionSuccess(action.type, action.index);
        this.emitChange(attr, value);
        resolve(value);
      }.bind(this);
    },

    toString: function() {
      return this.name;
    }
  });

  Store.extend = extendPrototype;

  return Store;
});