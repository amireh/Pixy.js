define(function(require) {
  var _ = require('underscore');
  var Logger = require('./mixins/logger');
  var Events = require('./mixins/events');
  var Dispatcher = require('./core/dispatcher');
  var extendPrototype = require('./util/extend');
  var RSVP = require('rsvp');

  var extend = _.extend;
  var CHANGE_EVENT = 'change';
  var RESPONSE_JSON = 'responseJSON';

  function onChange(resolve, attr, value) {
    this.emitChange(attr, value);
    resolve(arguments.length === 2 ? value : attr);
  }

  function onError(reject, error) {
    if (error && _.isObject(error) && RESPONSE_JSON in error) {
      error = error.responseJSON;
    }

    reject(error);
  }

  /**
   * @internal
   *
   * @note This is automatically generated for you and passed as an argument
   *       to #onAction.
   *
   * @param {Object} action
   *        The action specification.
   *
   * @param {String} action.type (required)
   *        Unique name of the action.
   *
   * @param {Integer} action.index (required)
   *        Action instance identifier as generated by the dispatcher.
   *
   * @return {Function}
   *         An "onError" function to pass to your action handler so that it
   *         calls it if it couldn't process the action.
   *
   *         The callback receives a single argument which should be an object
   *         describing your error.
   *
   *         The callback will emit the appropate action error.
   */
  function onAction(action) {
    if (!this.actions.hasOwnProperty(action.id)) {
      return RSVP.reject("Unknown action '" + action.id + "'");
    }

    return new RSVP.Promise(function(resolve, reject) {
      var _onChange = onChange.bind(this, resolve);
      var _onError = onError.bind(null, reject);

      try {
        this.actions[action.id].call(this, action.payload, _onChange, _onError);
      }
      catch(error) {
        onError(error);
      }
    }.bind(this));
  }

  /**
   * @class Pixy.Store
   *
   * An implementation of the Flux Data Store objects.
   */
  var Store = function(name, schema) {
    extend(this, schema, {
      name: name
    });

    this.reset();

    Dispatcher.register(name, onAction.bind(this));

    if (this.initialize) {
      this.initialize();
    }
  };


  extend(Store.prototype, Logger, Events, {
    name: 'GenericStore',
    actions: {},

    /**
     * Notify all subscribed listeners that the store's data has been updated.
     */
    emitChange: function(attr, value) {
      this.debug('Broadcasting change.');

      if (attr) {
        this.trigger('change:' + attr, value);
      }

      this.trigger(CHANGE_EVENT);
    },

    /**
     * @param {function} callback
     */
    addChangeListener: function(callback, thisArg) {
      if (thisArg && thisArg.listenTo) {
        thisArg.listenTo(this, CHANGE_EVENT, callback);
      } else {
        this.on(CHANGE_EVENT, callback, thisArg);
      }
    },

    /**
     * @param {function} callback
     */
    removeChangeListener: function(callback, thisArg) {
      if (thisArg && thisArg.listenTo) {
        thisArg.stopListening(this, CHANGE_EVENT, callback);
      } else {
        this.off(CHANGE_EVENT, callback, thisArg);
      }
    },

    reset: function() {
      this.state = this.getInitialState();
    },

    getInitialState: function() {
      return {};
    },

    setState: function(newState) {
      extend(this.state, newState);
      this.emitChange();
    }
  });

  Store.extend = extendPrototype;

  return Store;
});