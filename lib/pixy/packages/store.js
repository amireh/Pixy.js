define([
  'underscore',
  './mixins/logger',
  './mixins/events',
  './dispatcher',
  './registry'
], function(_, Logger, Events, Dispatcher, Registry) {
  var callbacks = [];
  var extend = _.extend;
  var CHANGE_EVENT = 'change';
  var ACTION_ERROR_EVENT = 'actionError';

  function actionErrorEventName(action) {
    return [ ACTION_ERROR_EVENT, action ].join(':');
  }

  function onPayload(action) {
    return this.onAction(action.type,
      action.payload,
      this.emitChange.bind(this),
      this._errorPropagator(action));
  }

  /**
   * @class Pixy.Store
   *
   * An implementation of the Flux Data Store objects.
   */
  var Store = function(name, schema) {
    extend(this, schema, {
      name: name
    });

    Dispatcher.register(onPayload.bind(this));
    Registry.registerModule(this.name, this);
  };

  extend(Store.prototype, Logger, Events, {
    name: 'GenericStore',

    /**
     * Notify all subscribed listeners that the store's data has been updated.
     */
    emitChange: function() {
      this.debug('Broadcasting change.');
      this.trigger(CHANGE_EVENT);
    },

    /**
     * Notify subscribers that an error was raised performing a specific store
     * action.
     *
     * @param  {String} action
     *         Name of the action in which the error was raisde.
     *
     * @param  {Integer} actionIndex
     *         The action index generated by the dispatcher.
     *
     * @param  {Object} error
     *         The error.
     */
    emitActionError: function(action, actionIndex, error) {
      this.warn('Broadcasting action error:', action, '#', actionIndex);

      this.trigger(actionErrorEventName(action), actionIndex, error);
      this.trigger(ACTION_ERROR_EVENT, action, actionIndex, error);
    },

    /**
     * @param {function} callback
     */
    addChangeListener: function(callback, thisArg) {
      this.on(CHANGE_EVENT, callback, thisArg);
    },

    /**
     * @param {function} callback
     */
    removeChangeListener: function(callback, thisArg) {
      this.off(CHANGE_EVENT, callback, thisArg);
    },

    /**
     * Register an error handler for a specific store action.
     *
     * @param {String}   action
     *        A specific action to listen to for errors. Errors caused in other
     *        actions will not be dispatched to your callback.
     *
     * @param {Function} callback
     */
    addActionErrorListener: function(action, callback, thisArg) {
      this.on(actionErrorEventName(action), callback, thisArg);
    },

    removeActionErrorListener: function(action, callback, thisArg) {
      this.off(actionErrorEventName(action), callback, thisArg);
    },

    /**
     * Register an error handler to be called on any store action error.
     *
     * @param {Function} callback
     */
    addErrorListener: function(callback, thisArg) {
      this.on(ACTION_ERROR_EVENT, callback, thisArg);
    },

    removeErrorListener: function(callback) {
      this.off(ACTION_ERROR_EVENT, callback, thisArg);
    },

    /**
     * @protected
     *
     * Dispatcher callback for this store. This is where you receive the payload
     * from the dispatcher and get a chance to handle the action if you know how
     * to.
     *
     * @param  {String} action
     *         Unique action id. Usually identified by a constant.
     *
     * @param  {Object} payload
     *         Action-specific parameters.
     *
     * @param {Function} onError
     *        Call this if your handler was unable to process the action.
     *        See #_errorPropagator for more information.
     */
    onAction: function(action, payload, onError) {
    },

    /**
     * @private
     *
     * @note This is automatically generated for you and passed as an argument
     *       to #onAction.
     *
     * @param {Object} action
     *        The action specification.
     *
     * @param {String} action.type (required)
     *        Unique name of the action.
     *
     * @param {Integer} action.index (required)
     *        Action instance identifier as generated by the dispatcher.
     *
     * @return {Function}
     *         An "onError" function to pass to your action handler so that it
     *         calls it if it couldn't process the action.
     *
     *         The callback receives a single argument which should be an object
     *         describing your error.
     *
     *         The callback will emit the appropate action error.
     */
    _errorPropagator: function(action) {
      return function(error) {
        this.emitActionError(action.type, action.index, error);
      }.bind(this);
    },

    toString: function() {
      return this.name;
    }
  });

  return Store;
});